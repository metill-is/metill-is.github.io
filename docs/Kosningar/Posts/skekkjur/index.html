<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Þegar við sjáum niðurstöður úr skoðanakönnunum á fylgi stjórnmálaflokka, þá eru þær byggðar á svörum ákveðins hóps fólks. En hvernig vitum við hversu nákvæmar þessar niðurstöður eru? Til að átta okkur á því, þurfum við að skilja hvað skekkjumörk eru og hvernig þau eru fundin.">

<title>Skekkjur og kannanir – Metill</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<link href="../../../favicon/favicon-32x32.png" rel="icon" type="image/png">
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&amp;display=swap" rel="stylesheet">

<meta property="og:title" content="Skekkjur og kannanir – Metill">
<meta property="og:description" content="Þegar við sjáum niðurstöður úr skoðanakönnunum á fylgi stjórnmálaflokka, þá eru þær byggðar á svörum ákveðins hóps fólks. En hvernig vitum við hversu nákvæmar þessar niðurstöður eru? Til að átta okkur á því, þurfum við að skilja hvað skekkjumörk eru og hvernig þau eru fundin.">
<meta property="og:site_name" content="Metill">
<meta name="twitter:title" content="Skekkjur og kannanir – Metill">
<meta name="twitter:description" content="Þegar við sjáum niðurstöður úr skoðanakönnunum á fylgi stjórnmálaflokka, þá eru þær byggðar á svörum ákveðins hóps fólks. En hvernig vitum við hversu nákvæmar þessar niðurstöður eru? Til að átta okkur á því, þurfum við að skilja hvað skekkjumörk eru og hvernig þau eru fundin.">
<meta name="twitter:creator" content="@bggjonsson">
<meta name="twitter:site" content="@bggjonsson">
<meta name="twitter:card" content="summary_large_image">
</head><body><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div><nav class="navbar m-0 p-0 bg-primary">

  <div class="container bg-primary text-secondary justify-content-center flex-wrap align-items-baseline">
    <div class="d-flex flex-row">
      <header class="blog-header m-0 p-0 justify-content-center">
          <div class="col-12 d-flex">
            <a href="../../../index.html" style="text-decoration: none;">
              <h1 class="icelandic-text navbar-brand text-secondary m-3 pb-0 mb-0">
                KosningaMetill 
              </h1>
            </a>
          </div>   
      </header>
    </div>  
        <div class="col-12 d-flex justify-content-center">
          <a class="p-2 pt-0 link-secondary navbar-link text-secondary" href="../../../index.html" style="text-decoration: none;">Kosningar</a>
          <a class="p-2 pt-0 link-secondary navbar-link text-secondary" href="../../../articles.html" style="text-decoration: none;">Greinar</a>
          <a class="p-2 pt-0 link-secondary navbar-link text-secondary" href="../../../about.html" style="text-decoration: none;">Um Metil</a>
        </div>
  </div>
</nav>
<meta name="quarto:status" content="draft">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../style.css">




<div id="quarto-search-results"></div>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Skekkjur og kannanir</h1>
            <p class="subtitle lead">Hvernig finnur maður skekkjumörk í könnunum á fylgi stjórnmálaflokka?</p>
                  <div>
        <div class="description">
          Þegar við sjáum niðurstöður úr skoðanakönnunum á fylgi stjórnmálaflokka, þá eru þær byggðar á svörum ákveðins hóps fólks. En hvernig vitum við hversu nákvæmar þessar niðurstöður eru? Til að átta okkur á því, þurfum við að skilja hvað skekkjumörk eru og hvernig þau eru fundin.
        </div>
      </div>
                </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Efnisyfirlit</h2>
   
  <ul>
  <li><a href="#tilviljunarkennd-og-kerfisbundin-skekkja" id="toc-tilviljunarkennd-og-kerfisbundin-skekkja" class="nav-link active" data-scroll-target="#tilviljunarkennd-og-kerfisbundin-skekkja">Tilviljunarkennd og kerfisbundin skekkja</a>
  <ul class="collapse">
  <li><a href="#tilviljanakennd-skekkja" id="toc-tilviljanakennd-skekkja" class="nav-link" data-scroll-target="#tilviljanakennd-skekkja">Tilviljanakennd skekkja</a></li>
  <li><a href="#kerfisbundin-skekkja" id="toc-kerfisbundin-skekkja" class="nav-link" data-scroll-target="#kerfisbundin-skekkja">Kerfisbundin Skekkja</a>
  <ul class="collapse">
  <li><a href="#hvernig-má-draga-úr-kerfisbundinni-skekkju" id="toc-hvernig-má-draga-úr-kerfisbundinni-skekkju" class="nav-link" data-scroll-target="#hvernig-má-draga-úr-kerfisbundinni-skekkju">Hvernig má draga úr kerfisbundinni skekkju?</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#samantekt" id="toc-samantekt" class="nav-link" data-scroll-target="#samantekt">Samantekt</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Þegar við sjáum niðurstöður úr skoðanakönnunum á fylgi stjórnmálaflokka, þá eru þær byggðar á svörum ákveðins hóps fólks. En hvernig vitum við hversu nákvæmar þessar niðurstöður eru? Til að átta okkur á því, þurfum við að skilja hvað skekkjumörk eru og hvernig þau eru fundin.</p>
<section id="tilviljunarkennd-og-kerfisbundin-skekkja" class="level1">
<h1>Tilviljunarkennd og kerfisbundin skekkja</h1>
<p>Skekkja í könnunum getur verið tvenns konar:</p>
<ol type="1">
<li><p><strong>Tilviljunarkennd skekkja</strong>: Þetta er sú óvissa sem stafar af því að við erum aðeins að taka sýnishorn af heildinni, ekki að spyrja alla. Ef við myndum endurtaka könnunina með nýju úrtaki, gætu niðurstöðurnar breyst örlítið vegna tilviljunar. Þessi skekkja minnkar þegar úrtakið stækkar. Stærra úrtak gefur nákvæmari mynd af heildinni.</p></li>
<li><p><strong>Kerfisbundin skekkja</strong>: Þetta er skekkja sem stafar af því að eitthvað í ferlinu veldur því að niðurstöðurnar skekkjast í ákveðna átt. Til dæmis ef hópurinn sem var spurður er ekki lýsandi fyrir fyrir allt samfélagið, eða ef ákveðnir hópar svara síður könnunum. Stærð úrtaksins hjálpar ekki við að minnka þessa skekkju; við þurfum að tryggja að úrtakið sé rétt valið og að svarhlutfallið sé hátt.</p></li>
</ol>
<section id="tilviljanakennd-skekkja" class="level2">
<h2 class="anchored" data-anchor-id="tilviljanakennd-skekkja">Tilviljanakennd skekkja</h2>
<p>Til að finna skekkjumörk fyrir tilviljunarkennda skekkju er oft notuð einföld formúla sem tekur tillit til stærðar úrtaksins og niðurstöðunnar úr könnuninni.</p>
<p><strong>1. Stærð úrtaksins skiptir máli</strong></p>
<p>Því fleiri sem taka þátt í könnuninni, því minni verður tilviljunarkennda skekkjan. Þetta er vegna þess að tölfræðileg óvissa minnkar með stærð úrtaks.</p>
<p><strong>2. Hlutfallið sem mælt er</strong></p>
<p>Skekkjumörkin eru einnig háð því hversu hátt hlutfallið er sem verið er að mæla. Skekkjan er mest þegar hlutfallið er nálægt 50% og minnst þegar það er nálægt 0% eða 100%. Þetta er vegna þess að dreifing hlutfalla fylgir tvíkostadreifingu.</p>
<p>Fyrir dæmigerða skoðanakönnun með 1000 manna úrtaki eru skekkjumörkin u.þ.b.: - <span class="math inline">\(\pm 3,1\%\)</span> fyrir flokk með 50% fylgi - <span class="math inline">\(\pm 2,7\%\)</span> fyrir flokk með 30% eða 70% fylgi - <span class="math inline">\(\pm 1,9\%\)</span> fyrir flokk með 10% eða 90% fylgi</p>
<p><strong>3. Dæmi um útreikning</strong></p>
<p>Algeng formúla fyrir skekkjumörk er:</p>
<p><span class="math display">\[
\pm 1,96 \times \sqrt{\frac{p(1-p)}{n}}
\]</span></p>
<p>Þar sem:</p>
<ul>
<li><span class="math inline">\(p\)</span> er hlutfallið sem mælist (t.d. 0,3 fyrir 30%)</li>
<li><span class="math inline">\(n\)</span> er fjöldi svarenda</li>
<li>1,96 er gildið sem gefur 95% öryggisbil þegar við nálgum hlutfallið með normaldreifingu</li>
</ul>
<p><strong>Dæmi:</strong> Ef flokkur mælist með 30% fylgi í 1000 manna könnun: <span class="math inline">\(\pm 1.96 \times \sqrt{\frac{0.3 \times 0.7}{1000}} = \pm 2.8\%\)</span></p>
<p>Þetta þýðir að með 95% vissu er raunverulegt fylgi flokksins á bilinu 27,2% til 32,8%.</p>
</section>
<section id="kerfisbundin-skekkja" class="level2">
<h2 class="anchored" data-anchor-id="kerfisbundin-skekkja">Kerfisbundin Skekkja</h2>
<p>Tilviljunarkennd skekkja er aðeins hluti af sögunni. Kerfisbundin skekkja getur haft jafnvel meiri áhrif á niðurstöðurnar.</p>
<ul>
<li><p><strong>Úrtaksskekkja</strong>: Ef hópurinn sem var spurður er ekki dæmigerður fyrir allt samfélagið, þá geta niðurstöðurnar skekkst. Til dæmis ef aðeins fólk á ákveðnum aldri eða búsetusvæði er spurt.</p></li>
<li><p><strong>Svarhlutfall</strong>: Ef aðeins hluti þeirra sem voru valdir til að taka þátt svara könnuninni, og þeir sem svara eru frábrugðnir þeim sem svara ekki, þá getur það valdið skekkju. Til dæmis gætu þeir sem hafa sterkar skoðanir verið líklegri til að svara.</p></li>
</ul>
<section id="hvernig-má-draga-úr-kerfisbundinni-skekkju" class="level3">
<h3 class="anchored" data-anchor-id="hvernig-má-draga-úr-kerfisbundinni-skekkju">Hvernig má draga úr kerfisbundinni skekkju?</h3>
<p>Þó ekki sé hægt að losna alveg við kerfisbundna skekkju, þá eru nokkrar leiðir til að draga úr henni. Mikilvægast er að huga vel að framkvæmd könnunarinnar frá upphafi til enda og nota viðurkenndar aðferðir við val á úrtaki og úrvinnslu gagna. Helstu leiðirnar eru:</p>
<section id="gæta-að-úrtakinu" class="level4">
<h4 class="anchored" data-anchor-id="gæta-að-úrtakinu">Gæta að úrtakinu</h4>
<p>Velja úrtak sem er sem líkast samfélaginu í heild, með tilliti til:</p>
<ul>
<li>Aldurs, kyns og búsetu</li>
<li>Menntunarstigs og tekna</li>
<li>Atvinnu og starfsstéttar</li>
<li>Fjölskyldugerðar</li>
<li>Búsetumynsturs (þéttbýli/dreifbýli)</li>
</ul>
<p>Þetta má gera með því að:</p>
<ul>
<li>Nota lagskipt úrtak þar sem þýðinu er skipt í hópa og hlutfallslega er valið úr hverjum þessara hópa</li>
<li>Nota kvótaúrtak þar sem tryggt er að ákveðið hlutfall þátttakenda komi úr hverjum hópi</li>
<li>Nota tilviljunarkennt úrtak úr þjóðskrá með góðri dreifingu</li>
</ul>
</section>
<section id="auka-svarhlutfall" class="level4">
<h4 class="anchored" data-anchor-id="auka-svarhlutfall">Auka svarhlutfall</h4>
<p>Hvetja fólk til að svara könnuninni með því að:</p>
<ul>
<li>Gera könnunina stutta og hnitmiðaða</li>
<li>Bjóða upp á svörun í gegnum síma, tölvupóst eða á netinu</li>
<li>Senda ítrekanir á kurteislegan hátt</li>
<li>Útskýra tilgang könnunarinnar og mikilvægi þátttöku</li>
<li>Tryggja nafnleynd og trúnað</li>
<li>Velja hentugan tíma fyrir könnunina (forðast t.d. sumarfrí)</li>
<li>Bjóða upp á hvata eins og þátttöku í happdrætti (þó þarf að gæta að því að það hafi ekki áhrif á niðurstöður)</li>
</ul>
</section>
<section id="vigtun" class="level4">
<h4 class="anchored" data-anchor-id="vigtun">Vigtun</h4>
<p>Vigtun er algeng aðferð til að leiðrétta fyrir skekkju í úrtaki. Hún virkar þannig að við notum tölfræðilegar aðferðir til að leiðrétta fyrir skekkju, til dæmis með því að vega svör þannig að þau endurspegli betur samsetningu samfélagsins:</p>
<ol type="1">
<li><strong>Þekktar breytur</strong>: Við berum saman hlutföll í úrtakinu við þekkt hlutföll í samfélaginu fyrir breytur eins og:
<ul>
<li>Aldursdreifingu</li>
<li>Kynjahlutföll</li>
<li>Búsetu</li>
<li>Menntunarstig</li>
</ul></li>
<li><strong>Útreikningur vægis</strong>: Hver þátttakandi fær vægi sem endurspeglar hversu vel hann fulltrúar sinn hóp. Til dæmis:
<ul>
<li>Ef ungt fólk er vanmetið í úrtakinu fá svör þeirra hærra vægi</li>
<li>Ef eldra fólk er ofmetið fá svör þeirra lægra vægi</li>
</ul></li>
<li><strong>Takmarkanir</strong>: Vigtun getur aðeins leiðrétt fyrir þær breytur sem við þekkjum. Ef aðrar mikilvægar breytur hafa áhrif á fylgi flokkanna en eru ekki notaðar í vigtuninni, getur skekkjan enn verið til staðar.</li>
</ol>
<section id="dæmi-um-vigtun" class="level5">
<h5 class="anchored" data-anchor-id="dæmi-um-vigtun">Dæmi um vigtun</h5>
<p>Segjum að við séum að kanna viðhorf til lengingar fæðingarorlofs. Við fáum 1000 svör í könnunina, en úrtakið er ekki alveg dæmigert fyrir samfélagið:</p>
<ul>
<li>Konur eru 70% svarenda (en eru 50% þjóðarinnar)</li>
<li>Fólk 50 ára og eldra er 60% svarenda (en er 35% þjóðarinnar)</li>
</ul>
<p>Ef við vitum að:</p>
<ul>
<li>Konur eru almennt hlynntari lengingu fæðingarorlofs en karlar</li>
<li>Yngra fólk er almennt hlynntara lengingu en eldra fólk</li>
</ul>
<p>Þá gætu óvigtuð svör gefið skakka mynd af raunverulegum viðhorfum þjóðarinnar. Með vigtun getum við leiðrétt fyrir þessu með því að:</p>
<ul>
<li>Gefa svörum karla meira vægi (þar sem þeir eru vanmetinn hópur í úrtakinu)</li>
<li>Gefa svörum yngra fólks meira vægi (þar sem það er vanmetinn hópur í úrtakinu)</li>
</ul>
<p>Þannig fáum við niðurstöður sem endurspegla betur raunveruleg viðhorf í samfélaginu.</p>
</section>
</section>
</section>
</section>
</section>
<section id="samantekt" class="level1">
<h1>Samantekt</h1>
<p>Þegar við skoðum kannanir á fylgi stjórnmálaflokka er mikilvægt að hafa í huga:</p>
<ol type="1">
<li><strong>Tilviljunarkennd skekkja</strong></li>
</ol>
<ul>
<li>Minnkar með stærra úrtaki</li>
<li>Er mest þegar fylgi er nálægt 50%</li>
<li>Hægt að reikna nákvæm skekkjumörk</li>
</ul>
<ol start="2" type="1">
<li><strong>Kerfisbundin skekkja</strong></li>
</ol>
<ul>
<li>Getur haft meiri áhrif en tilviljunarkennd skekkja</li>
<li>Stærra úrtak lagar ekki vandann</li>
<li>Helstu orsakir:
<ul>
<li>Úrtak ekki dæmigert fyrir samfélagið</li>
<li>Lágt svarhlutfall</li>
<li>Mismunandi svarhneigð ólíkra hópa</li>
</ul></li>
<li>Skekkjumörk endurspegla ekki óvissuna rétt</li>
</ul>
<ol start="3" type="1">
<li><strong>Leiðir til úrbóta</strong></li>
</ol>
<ul>
<li>Vanda val á úrtaki</li>
<li>Auka svarhlutfall</li>
<li>Nota vigtun til að leiðrétta fyrir þekktum skekkjum</li>
<li>Bera saman niðurstöður frá mörgum könnunaraðilum</li>
</ul>
<ol start="4" type="1">
<li><strong>Túlkun niðurstaðna</strong></li>
</ol>
<ul>
<li>Skoða alltaf skekkjumörk</li>
<li>Hafa í huga mögulegar kerfisbundnar skekkjur og áhrif þeirra á skekkjumörk</li>
<li>Varast að oftúlka litlar breytingar</li>
<li>Meta áreiðanleika könnunaraðila</li>
</ul>
<p>Með þessum atriðum í huga erum við betur í stakk búin til að túlka niðurstöður skoðanakannana og meta áreiðanleika þeirra.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/metill\.is");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../about.html">
<p>About</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>